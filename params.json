{"name":"SPA на React, NodeJS, Express и MongoDB","tagline":"Вебинар проходил 10 марта 2015","body":"# Материалы к вебинару \"Разработка SPA на React, NodeJS, Express и MongoDB\"\r\n\r\n### План вебинара\r\n\r\n - Краткое введение в NodeJS и npm\r\n - Написание простого сервера на NodeJS\r\n - Кратко о MongoDB, взаимодействие с базой данных\r\n - Написание компонентов на ReactJS\r\n - Кратко об архитектуре Flux\r\n - Получение и обработка данных с API\r\n - Распределение данных внутри приложения\r\n - Динамика в приложении\r\n\r\n### Вспомогательные материлы\r\n\r\nВ рамках данного вебинара мы напишем небольшое приложение для создания и хранения заметок ([такое](ccылка)) на NodeJS, Express, MongoDB и React.\r\n\r\n#### 1. Введение в Node.js и npm\r\n\r\nNode.js - программная платформа, основанная на движке Javascript V8. Она позволяет выполнять Javascript код на сервере.\r\n\r\nПервое, что нужно сделать - это установить Node.js. Вместе с ним в комплекте идет также и npm (Node Package Manager) - менеджер пакетов. В зависимости от используемой операционной системы, у Вас естьтакие варианты:\r\n\r\n - Для Windows: [скачать .msi установщик](https://nodejs.org/en/download)\r\n - Для Linux: запустить ```curl -L https://npmjs.org/install.sh | sh``` в терминале\r\n - Для Mac: [скачать .pkg установщик](https://nodejs.org/en/download) или ```brew install node```, если используете [Homebrew](http://brew.sh/)\r\n\r\nПосле установки, можно проверить наличие Node.js и npm на Вашем компьютере.\r\n\r\n```\r\nnode -v\r\nv5.1.0\r\n\r\nnpm -v\r\n3.3.12\r\n```\r\n\r\n#### 2. Hello world на Node.js\r\n\r\nДавайте приступим к делу и напишем наше первое Node.js приложение «Hello world».\r\n\r\nОткройте любой редактор и создайте файл под названием helloworld.js. В нем мы хотим вывести строку «Hello world» в консоль, для этого пишем следующий код:\r\n\r\n```\r\nconsole.log(\"Hello World\");\r\n```\r\n\r\nСохраняем файл и выполняем его посредством Node.js из терминала:\r\n\r\n```\r\nnode helloworld.js\r\n```\r\n\r\nЭта команда должна вывести Hello World в вашем терминале.\r\n\r\n#### 3. Постановка задачи\r\n\r\nМы будем создавать приложения для работы с заметками с таким функционалом:\r\n\r\n    1. Добавить заметку\r\n    2. Просмотреть заметки\r\n    3. Удалить заметку\r\n\r\nВ самом начале, нам нужно спроектировать API сервера. Исходя из определенного выше функционала и опираясь на методолгию REST, нам понадобятся такие вызовы:\r\n\r\n    `GET /notes` - получить все заметки\r\n    `POST /notes` - создать новую заметку\r\n    `DELETE /notes/:id` - удалить заметку\r\n\r\n#### 4. Использование Express\r\n\r\n[Express](http://expressjs.com/) - это минималистичный и гибкий веб-фреймворк для приложений Node.js, предоставляющий обширный набор функций. Он значительно упрощает маршрутизацию, использование промежуточных обработчиков (middleware), обработку запросов и отладку.\r\n\r\nСоздадим новую папку для проекта. Добавим в нее файл `package.json` приблизительно такого содержания:\r\n\r\n```\r\n{\r\n  \"name\": \"NotesApp\",\r\n  \"version\": \"0.0.1\",\r\n  \"description\": \"Notes application\",\r\n  \"scripts\": {\r\n    \"server\": \"babel-node server/app.js\",\r\n  },\r\n  \"author\": {\r\n    \"name\": \"Kateryna Porshnieva\",\r\n    \"email\": \"k.porshnieva@gmail.com\",\r\n    \"url\": \"https://github.com/krambertech\"\r\n  },\r\n  \"dependencies\": {\r\n    \"body-parser\": \"*\",\r\n    \"cors\": \"*\",\r\n    \"express\": \"*\",\r\n    \"mongoose\": \"*\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"babel\": \"5.x\",\r\n    \"babel-loader\": \"5.x\"\r\n  }\r\n}\r\n\r\n```\r\n\r\nСоздадим папку `/server` - в ней будет храниться весь код, относящийся к серверной части приложения (бекенд). В ней создадим файл `app.js` - главный файл нашего сервера.\r\n\r\n**Примечание:** Весь последующий код будет написан в стандарте ES2015 (ES6).\r\n\r\n```\r\nimport express from 'express';\r\n\r\nconst app = express();\r\n\r\nconst server = app.listen(8080, () => {\r\n    console.log(`Server is up and running on port 8080`);\r\n});\r\n```\r\n\r\nЗдесь мы создали express-приложение и запустили веб-сервер на порте 8080. Для того, чтобы запустить его нужно выполнить в терминале `babel-node server/app.js`.\r\n\r\nПока что наш сервер ничего не умеет делать, давайте создадим для него новый маршрут:\r\n\r\n```\r\nimport express from 'express';\r\n\r\nconst app = express();\r\n\r\napp.get('/', (req, res) => {\r\n    res.send('Hello World!');\r\n});\r\n\r\nconst server = app.listen(8080, () => {\r\n    console.log(`Server is up and running on port 8080`);\r\n});\r\n```\r\n\r\nТеперь если открыть http://localhost:8080/ то вы увидите надпись \"Hello world\". Маршруты в Express описываются очень просто:\r\n\r\n```\r\napp.get('/grapes', (req, res) => {});\r\napp.post('/grapes', (req, res) => {});\r\napp.put('/grapes', (req, res) => {});\r\napp.delete('/grapes', (req, res) => {});\r\n```\r\n\r\nВы пишете `app.метод(маршрут, функция)`. Маршрут затем будет трансформирован в резулярное выражение, чтобы сервер понимал какие запросы как нужно обработать. Функция принимает объекты req ([объект запроса](http://expressjs.com/ru/4x/api.html#req)), res ([объект ответа](http://expressjs.com/ru/4x/api.html#res)) и next (функцию для вызова следующего обработчика).\r\n\r\n#### 5. MongoDB и mongoose\r\n\r\nMongoDB - это документо-ориентированная СУБД. Данные в MongoDB хранятся в документах, которые объединяются в коллекции. Каждый документ представляет собой JSON-подобную структуру (BSON). Проведя аналогию с реляционными СУБД, можно сказать, что коллекциям соответствуют таблицы, а документам — строки в таблицах. В отличие от РСУБД MongoDB не требует какого-либо описания схемы базы данных — она может постепенно меняться по мере развития приложения, что есть удобно.\r\n\r\nCначала нужно установить MongoDB на свой компьютер. Cсылка для скачивания: https://www.mongodb.org/downloads\r\n\r\n**Инструкция по установке на Windows:** http://metanit.com/nosql/mongodb/1.2.php\r\n\r\nMongoose — самый популярный модуль для работы с mongodb на javascript. Он позволяет очень удобно работать с базой данных, в нем все строится на схемах данных. То есть вы создаете модель хранимых данных в базе, а он уже помогает их типизировать, валидировать, строить бизнес логику поверх них, создавать запросы и т.д.\r\n\r\nВ базе данных мы будем хранить заметки. Так как в mongoose все строится на моделях данных, нам нужно создать модель (схему) для заметок. Делается это очень просто:\r\n\r\n```\r\nimport mongoose from \"mongoose\";\r\n\r\nconst Schema = mongoose.Schema;\r\n\r\nconst NoteSchema = new Schema({\r\n    title     : { type: String },\r\n    text      : { type: String, required: true },\r\n    color     : { type: String },\r\n    createdAt : { type: Date }\r\n});\r\n\r\nconst Note = mongoose.model('Note', NoteSchema);\r\n```\r\n\r\nЕсть огромное множество встроенных типов и приемов для работы с данными - все их вы можете найти в документации - http://mongoosejs.com/docs/\r\n\r\nСейчас мы создали схему для заметки, а потом, на основе этой схемы, модель. Модель - это класс, с помощью которого будут строиться документы в коллекции. В этом случае, каждый документ будет заметкой с параметрами и поведением, которое мы определили. Например, у каждой заметки есть заголовок, текст, цвет и дата создания. Из всех полей, только тект является обязательным - он помечен `required`.\r\n\r\nТакже к схемам можно добавлять методы:\r\n\r\n```\r\nvar mongoose = require('mongoose');\r\nmongoose.connect('mongodb://localhost/kittens');\r\n\r\nvar kittySchema = mongoose.Schema({\r\n    name: String\r\n});\r\n\r\nkittySchema.methods.speak = function () {\r\n  var greeting = this.name\r\n    ? \"Meow name is \" + this.name\r\n    : \"I don't have a name\";\r\n  console.log(greeting);\r\n}\r\n\r\nvar Kitten = mongoose.model('Kitten', kittySchema);\r\n\r\nvar fluffy = new Kitten({ name: 'fluffy' });\r\n\r\nfluffy.speak();\r\n```\r\n\r\nМы с вами создали говорящих котят. Для того, чтобы сохранить Флаффи в базу данных, нам нужно просто написать:\r\n\r\n```\r\nfluffy.save(function (err, fluffy) {\r\n  if (err) return console.error(err);\r\n  fluffy.speak();\r\n});\r\n```\r\n\r\nТеперь для того, чтобы получить всех котят, мы можем использовать метод find:\r\n\r\n```\r\nKitten.find(function (err, kittens) {\r\n  if (err) return console.error(err);\r\n  console.log(kittens);\r\n})\r\n```\r\n\r\nЧтобы найти всех котят по имени fluffy:\r\n\r\n```\r\nKitten.find({ name: \"fluffy\" }, callback);\r\n```\r\n\r\nТеперь давайте отойдем от котят и вернемся к нашим заметкам. Сохраним модель заметки в папке `/server/models/Note.js`. Теперь нужно связать взаимодействие с базой данных и запросы. Для работы с базой мы создадим утилиту `server/utils/DataBaseUtils.js`, в которой просто изолируем методы для работы с базой.\r\n\r\nСначала нам нужно настроить соединение:\r\n\r\n```\r\nimport mongoose from \"mongoose\";\r\n\r\nimport '../models/Note';\r\n\r\nconst Note = mongoose.model('Note');\r\n\r\nexport function setUpConnection() {\r\n    mongoose.connect(`mongodb://localhost/notes`);\r\n}\r\n```\r\n\r\nИ добавим несколько методов для взаимодействия с базой:\r\n\r\n```\r\nexport function listNotes(id) {\r\n    return Note.find();\r\n}\r\n\r\nexport function createNote(data) {\r\n    const note = new Note({\r\n        title: data.title,\r\n        text: data.text,\r\n        color: data.color,\r\n        createdAt: new Date()\r\n    });\r\n\r\n    return note.save();\r\n}\r\n\r\nexport function deleteNote(id) {\r\n    return Note.findById(id).remove();\r\n}\r\n```\r\n\r\nТеперь нужно создать соответствующие маршруты. Вернемся к файлу `/server/app.js`.\r\n\r\nДанные мы будем получать в формате json, для того, чтобы удобно с ними взаимодействовать мы будем использовать промежуточный обработчик [body-parser](https://github.com/expressjs/body-parser). Он будет вызван всякий раз, когда прийдет запрос - он сначала преобразует данные, а затем передаст управление нашим обработчикам.\r\n\r\nИспользуется он таким образом:\r\n\r\n```\r\nimport bodyParser from 'body-parser';\r\n\r\n// ...\r\n\r\napp.use( bodyParser.json() );\r\n```\r\n\r\nТеперь данные, полученые в json формате будут обработаны корректно.\r\n\r\nВ итоге, наш файл `app.js` выглядит вот так:\r\n\r\n```\r\nimport express from 'express';\r\nimport bodyParser from 'body-parser';\r\n\r\nimport * as db from './utils/DataBaseUtils';\r\n\r\n// Initialization of express application\r\nconst app = express();\r\n\r\n// Set up connection of database\r\ndb.setUpConnection();\r\n\r\n// Using bodyParser middleware\r\napp.use( bodyParser.json() );\r\n\r\n// RESTful api handlers\r\napp.get('/notes', (req, res) => {\r\n    db.listNotes().then(data => res.send(data));\r\n});\r\n\r\napp.post('/notes', (req, res) => {\r\n    db.createNote(req.body).then(data => res.send(data));\r\n});\r\n\r\napp.delete('/notes/:id', (req, res) => {\r\n    db.deleteNote(req.params.id).then(data => res.send(data));\r\n});\r\n\r\nconst server = app.listen(8080, function() {\r\n    console.log(`Server is up and running on port 8080`);\r\n```\r\n\r\nПосле обращения к базе мы используем промисы (Promise), они предоставляют удобный способ организации асинхронного кода.\r\n\r\nНа этом почти все, мы создали серверное приложение на node.js. Еще было бы неплохо создать для него конфигурацию, то есть вынести некоторые переменные в конфиг. Создадим файл `/etc/config.json`:\r\n\r\n```\r\n{\r\n    \"apiPrefix\": \"http://localhost:8080\",\r\n    \"serverPort\": \"8080\",\r\n    \"db\":{\r\n        \"name\": \"notes\",\r\n        \"host\": \"localhost\",\r\n        \"port\": 27017\r\n    }\r\n}\r\n```\r\n\r\nТеперь при использовании этих переменных, будем обращаться к этому файлу.\r\n\r\n**app.js**\r\n```\r\nimport express from 'express';\r\nimport cors from 'cors';\r\nimport bodyParser from 'body-parser';\r\n\r\nimport { serverPort } from '../etc/config.json';\r\n\r\nimport * as db from './utils/DataBaseUtils';\r\n\r\n// Initialization of express application\r\nconst app = express();\r\n\r\n// Set up connection of database\r\ndb.setUpConnection();\r\n\r\n// Using bodyParser middleware\r\napp.use( bodyParser.json() );\r\n\r\n// Allow requests from any origin\r\napp.use(cors({ origin: '*' }));\r\n\r\n// RESTful api handlers\r\napp.get('/notes', (req, res) => {\r\n    db.listNotes().then(data => res.send(data));\r\n});\r\n\r\napp.post('/notes', (req, res) => {\r\n    db.createNote(req.body).then(data => res.send(data));\r\n});\r\n\r\napp.delete('/notes/:id', (req, res) => {\r\n    db.deleteNote(req.params.id).then(data => res.send(data));\r\n});\r\n\r\nconst server = app.listen(serverPort, function() {\r\n    console.log(`Server is up and running on port ${serverPort}`);\r\n});\r\n```\r\n\r\n**DataBaseUtils.js**\r\n```\r\nimport mongoose from \"mongoose\";\r\n\r\nimport config from '../../etc/config.json';\r\n\r\nimport '../models/Note';\r\n\r\nconst Note = mongoose.model('Note');\r\n\r\nexport function setUpConnection() {\r\n    mongoose.connect(`mongodb://${config.db.host}:${config.db.port}/${config.db.name}`);\r\n}\r\n\r\nexport function listNotes(id) {\r\n    return Note.find();\r\n}\r\n\r\nexport function createNote(data) {\r\n    const note = new Note({\r\n        title: data.title,\r\n        text: data.text,\r\n        color: data.color,\r\n        createdAt: new Date()\r\n    });\r\n\r\n    return note.save();\r\n}\r\n\r\nexport function deleteNote(id) {\r\n    return Note.findById(id).remove();\r\n}\r\n```\r\n\r\n#### 6. Введение в React\r\n\r\nReactJS - это JаvaScript библиотека для построения пользовательских интерфейсов. Это не MVC фреймворк. К нему можно применить только V из этой аббревиатуры. Такая узкая сфера применения дает свободу использования React в различных системах в комбинации с другими библиотеками.\r\n\r\nReact был представлен Facebook в 2013 году, и очень быстро обрел популярность. Сегодня его используют многие известные компании включая Instagram, Airbnb, Ebay, Netflix, Yahoo и другие.\r\n\r\nОсновным отличием React от других JavaScript фреймворков является то, как он управляет состоянием приложения. Если вспомнить, как пользователи взаимодействовали с веб-страницами еще 10-15 лет назад, то увидим такую картину:\r\n\r\n![](https://github.com/krambertech/react-essential-course/raw/master/01-introduction-to-react/images/001.png)\r\n\r\nСервер всегда возвращал статическую страницу, и реакцией на действия пользователя была полная перезагрузка страницы. Преимуществами такого подхода, была простота в реализации и понимании, недостатками - скорость работы, отзывчивость, UX и потеря состояния при каждой перезагрузке.\r\n\r\nВсе очень изменилось с появлением AJAX, это подход к построению интерактивных веб-приложений, заключающийся в «фоновом» обмене данными браузера с веб-сервером. То есть, в фоновом режиме отправляются запросы на сервер, приходят с него ответы, изменяется состояние приложения и, соответственно, внешний вид. Именно такой подход породил понятие Single Page Application.\r\n\r\n![](https://github.com/krambertech/react-essential-course/raw/master/01-introduction-to-react/images/002.png)\r\n\r\nНо каждое визуальное изменение на странице соответствует изменению ее DOM дерева. Не секрет, что все манипуляции с DOM деревом являются очень ресурсоемкими операциями, т.к. изначально DOM дерево было статическим и никакой динамики не предусматривало.\r\n\r\n![](https://github.com/krambertech/react-essential-course/raw/master/01-introduction-to-react/images/006.png)\r\n\r\nИменно поэтому в React используется виртуальный DOM. Это такая легковесная копия реального DOM дерева на Javascript. Таким образом, React манипулирует не с реальным (синоним - медленным) DOM деревом, а с виртуальным.\r\n\r\n![](https://github.com/krambertech/react-essential-course/raw/master/01-introduction-to-react/images/003.png)\r\n\r\nОн сравнивает предыдущее состояние виртуального DOM дерева с его следующим состоянием и находит минимальное количество манипуляций, которые можно произвести уже с реальным DOM, чтобы обновить вид приложения согласно его новому состоянию.\r\n\r\n![](https://github.com/krambertech/react-essential-course/raw/master/01-introduction-to-react/images/004.png)\r\n\r\nИ это действительно быстро работает. А все что вам нужно делать - это просто менять состояние вашего приложения, а все остальное React сделает уже за вас!\r\n\r\nВсе приложение на React строится из небольших кирпичиков - компонентов. Такое построение приложения упрощает поддержку и работу над кодом в команде. В идеале, все компоненты должны быть независимыми и каждый должен делать свою задачу и делать ее хорошо.\r\n\r\n#### JSX\r\n\r\nДля рендеринга данных в React используется JSX. JSX нужен для JavaScript XML — разметки в стиле XML внутри компонентов React. React работает и без JSX, но именно JSX поможет сделать ваши компоненты более читаемыми, поэтому рекомендуется использовать его.\r\n\r\n```jsx\r\n// с JSX\r\nvar app = <Nav color=“blue\">\r\n    <Profile>click</Profile>\r\n</Nav>;\r\n```\r\n\r\n```javascript\r\n// без JSX\r\nvar app = React.createElement(\r\n    Nav,\r\n    {color:\"blue\"},\r\n    React.createElement(\r\n        Profile,\r\n        null,\r\n        \"click\"\r\n    )\r\n);\r\n```\r\n\r\nJSX позволяет вам описывать структуру компонентов с помощью понятного синтаксиса, а затем все написанное вами преобразуется в цепочку javascript функций.\r\n\r\nВ JSX можно использовать переменные, условные конструкции и вызывать функции. Для этого нужно использовать фугурные скобки.\r\n\r\n```javascript\r\nvar myName = 'Katya';\r\nvar app = <h1> My name is {myName}! </h1>;\r\n```\r\n\r\n```jsx\r\nfunction getMyName() {\r\n    return 'Katya';\r\n}\r\n\r\nvar app = <h1>\r\n    My name is {getMyName()}!\r\n</h1>;\r\n```\r\n\r\n```jsx\r\nvar age = 20;\r\n\r\nvar app = <h1>\r\n    Hi! { age > 18 ? 'Your age is more than 18!' : 'Your age is less than 18!' }\r\n</h1>;\r\n```\r\n\r\n#### Компоненты\r\n\r\nReact использует компонентную модель, то есть все большое приложение делится на небольшие независимые компоненты, которыми гораздо легче управлять.\r\n\r\n```jsx\r\n// простой компонент\r\nvar HelloWorld = React.createClass({\r\n    render: function() {\r\n        return (\r\n            <h1> Hello world! </h1>\r\n        );\r\n    }\r\n});\r\n```\r\n\r\nУ каждого компонента есть один обязательный метод - ```render```, который возвращает JSX разметку, соответствующую виду компонента.\r\n\r\n#### Параметры aka props\r\n\r\nКаждый компонент может принимать параметры. Они передаются из выше стоящих компонентов.  К параметрам компонента можно обращаться используя ```this.props.propName```.\r\n\r\n```jsx\r\nvar Heading = React.createClass({\r\n    render: function() {\r\n        return <h1> My name is {this.props.name}!</h1>;\r\n    }\r\n});\r\n\r\nvar Hello = React.createClass({\r\n    render: function() {\r\n        return <Heading name=\"Katya\" />;\r\n    }\r\n});\r\n```\r\n\r\nЗапомните: Модифицировать ```this.props``` **крайне нежелательно***!\r\n\r\n#### Состояние aka state\r\n\r\nТакже каждый компонент может хранить свое состояние. К нему можно получить доступ, обратившись к ```this.state```. В состоянии компонента стоит хранить данные, от которых компонент напрямую зависит внешний вид компонента, и при изменении которых его внешний вид тоже должен меняться (будет вызываться метод ```render```). Cостояние компонента доступно только внутри самого компонента. Для объявления начального состояния компонента, нужно использовать метод ```getInitialState```. Этот метод вызывается до того, как компонент отобразиться в доме и определяет первоначальное значение состояния компонента. Для того, чтобы модифицировать состояние компонента нужно вызвать метод ```this.setState({ /* новое состояние */ })```, тогда состояние компонента измениться и вызовется метод ```render```.\r\n\r\n```jsx\r\nvar Component = React.createClass({\r\n  getInitialState : function() {\r\n    return {\r\n      name : \"Katya\"\r\n    };\r\n  },\r\n\r\n  handleClick : function() {\r\n    this.setState({\r\n      name : \"Vasya\"\r\n    });\r\n  },\r\n\r\n  render : function() {\r\n    return <div onClick={this.handleClick}>\r\n      Hello, {this.state.name}\r\n    </div>;\r\n  }\r\n});\r\n\r\n```\r\n\r\n**Состояние нужно использовать только там, где это действительно необходимо!**\r\n\r\n**НИКОГДА** не нужно модифицировать ```this.state``` напрямую!\r\n\r\n#### Обработка событий\r\n\r\nЕсли вы захотите сделать свои компоненты динамическими, то вам не обойтись без использования событий. Обычно, для каждого события описывается обработчик, в котором вы можете произвести какие-то действия.\r\n\r\n```jsx\r\nvar HelloComponent = React.createClass({\r\n  handleClick : function() {\r\n    alert('Hello stranger!');\r\n  },\r\n\r\n  render : function() {\r\n    return <button onClick={this.handleClick}> Say hello </button>;\r\n  }\r\n});\r\n```\r\n\r\nВо все такие обработчики событий в качестве аргумента приходит объект ```SyntheticEvent```. Это объект, который является кроссбраузерной оберткой над стандартными событиями.\r\n\r\n```jsx\r\nvar EventComponent = React.createClass({\r\n  handleClick : function(event) {\r\n    alert('Event handled - ' + event.type); // Event handled - click\r\n  },\r\n\r\n  render : function() {\r\n    return <button onClick={this.handleClick}> Click me </button>;\r\n  }\r\n});\r\n```\r\n\r\nО том, какие события поддерживаются можно прочитать [тут](https://facebook.github.io/react/docs/events.html).\r\n\r\n#### ReactJS Hello world\r\n\r\nНачнем с простого подключения React в html документе\r\n\r\n```\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Hello World!</title>\r\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/0.14.0/react.js\"></script>\r\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/0.14.0/react-dom.js\"></script>\r\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.6.15/browser.js\"></script>\r\n</head>\r\n<body>\r\n    <div id='content'></div>\r\n\r\n    <script type=\"text/babel\">\r\n        const HelloWorld = React.createClass({\r\n            render() {\r\n                return (\r\n                    <h1> Hello world! </h1>\r\n                );\r\n            }\r\n        });\r\n\r\n        ReactDOM.render(\r\n            <HelloWorld />,\r\n            document.getElementById('content')\r\n        );\r\n    </script>\r\n</body>\r\n</html>\r\n```\r\n\r\nВ параметрах мы можем передавать значения компоненту, которые он будет уже использовать внутри себя, обращаясь к `this.props`.\r\n\r\n```\r\nconst HelloWorld = React.createClass({\r\n    render() {\r\n        return (\r\n            <h1> Hello, {this.props.name}! </h1>\r\n        );\r\n    }\r\n});\r\n\r\nReactDOM.render(\r\n    <HelloWorld name='Vasya' />,\r\n    document.getElementById('content')\r\n);\r\n```\r\n\r\nТакже мы можем добавить динамику в компонент с помощью использования состояния и обработки событий.\r\n\r\n\r\n```\r\nconst HelloWorld = React.createClass({\r\n    getInitialState() {\r\n        return {\r\n            name: 'Vasya'\r\n        };\r\n    },\r\n\r\n    handleNameChange(e) {\r\n        this.setState({\r\n            name: e.target.value\r\n        });\r\n    },\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <h1> Hello {this.state.name}! </h1>\r\n                <input type='text' value={this.state.name} onChange={this.handleNameChange} />\r\n            </div>\r\n        );\r\n    }\r\n});\r\n\r\nReactDOM.render(\r\n    <HelloWorld />,\r\n    document.getElementById('content')\r\n);\r\n```\r\n\r\n#### Сборка приложения\r\n\r\nДля более сложных проектов уже не выйдет все компоненты описать в index.html. Обычно создается отдельный файл для компонента, то компонент `Button` будет находиться в файле `Button.jsx`, а если у него еще есть отдельный файл со стилями, то мы создадим файл `Button.css` и расположим рядом с файлом компонента и подключим в нем. Основная идея такого подхода стоит в том, чтобы максимально изолировать компонент и все относящиеся к нему зависимости.\r\n\r\nТогда создадим в нащем проекте папку `/client`, в которой будет располагаться весь код, относящийся к клиентской части приложения. Также мы должны создать главный файл проекта, так называемую \"точку входа\". Из которого мы будем уже подключать другие модули, а они следующие и так далее. Создадим файл `main.js`.\r\n\r\n```\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\n\r\nReactDOM.render(\r\n    <h1>Notes</h1>,\r\n    document.getElementById('mount-point')\r\n);\r\n```\r\n\r\nДля того, чтобы кучу совершенно разных кусочков проекта (стили, js, json, jsx и т.д.) собрать воедино существуют системы сборки. Их сейчас есть достаточно много: gulp, grunt, broccoli, browserify и т.п. Но мы будем говорить о webpack. Почему именно он? Все очень просто - это самое универсальное и комплексное решение.\r\n\r\n![](https://webpack.github.io/assets/what-is-webpack.png)\r\n\r\nУстановим webpack глобально:\r\n\r\n```\r\nnpm install webpack -g\r\n```\r\n\r\nПри этом, в нем весь процесс сборки проекты описывается достаточно просто. Вот, например, как будет выглядеть наш конфиг:\r\n\r\n```\r\nvar webpack = require('webpack');\r\n\r\nmodule.exports = {\r\n    entry: \"./client/main.js\",\r\n    output: {\r\n        path: __dirname + '/public/build/',\r\n        publicPath: \"build/\",\r\n        filename: \"bundle.js\"\r\n    },\r\n    module: {\r\n        loaders: [\r\n            {\r\n                test: /\\.js$/,\r\n                loader: \"babel\",\r\n                exclude: [/node_modules/, /public/]\r\n            },\r\n            {\r\n                test: /\\.less$/,\r\n                loader: \"style-loader!css-loader!autoprefixer-loader!less\",\r\n                exclude: [/node_modules/, /public/]\r\n            },\r\n            {\r\n                test: /\\.jsx$/,\r\n                loader: \"react-hot!babel\",\r\n                exclude: [/node_modules/, /public/]\r\n            },\r\n            {\r\n                test: /\\.json$/,\r\n                loader: \"json-loader\"\r\n            }\r\n        ]\r\n    }\r\n}\r\n```\r\n\r\nМы описывает то, что должно быть на входе и то, что мы хотим получить на выходе. Для осуществления преобразований файлов используются загрузчики.\r\n\r\nЧтобы запустить сборку, нужно в терминале выполнить команду\r\n\r\n```\r\nwebpack -p\r\n```\r\n\r\nТогда появится файл `bundle.js` cо всем уже минифицированным кодом.\r\n\r\nТакже для webpack есть утилита `webpack-dev-server` для запуска development-сервера и отслеживания изменений в файлах. В него можно подключить как hot-reload - автоматическую перезагрузку страницы браузера при изменении файлов проекта, так и hot-module-replacement - возможность при изменении исходников очень быстро отобразить изменения в браузере без перезагрузки страницы, выглядит как магия.\r\n\r\nДля запуска `webpack-dev-server` нам нужно выполнить такую команду:\r\n\r\n```\r\nwebpack-dev-server --debug --hot --devtool eval-source-map --output-pathinfo --watch --colors --inline --content-base public --port 8090 --host 0.0.0.0\r\n```\r\n\r\nНо чтобы такое безобразие каждый раз неписать в консоли, давайте добавим ее в `scripts` в `package.json`.\r\n\r\n```\r\n  \"scripts\": {\r\n    \"webpack-devserver\": \"webpack-dev-server --debug --hot --devtool eval-source-map --output-pathinfo --watch --colors --inline --content-base public --port 8090 --host 0.0.0.0\"\r\n  }\r\n```\r\n\r\nТеперь мы можем просто писать `npm run webpack-devserver` и данная команда будет выполнена.\r\n\r\n#### Flux\r\n\r\nFlux — это архитектура, которую команда Facebook использует при работе с React. Это не фреймворк, или библиотека, это новый архитектурный подход, который дополняет React и принцип однонаправленного потока данных.\r\n\r\n\r\n\r\nТипичная реализация архитектуры Flux может использовать эту библиотеку вместе с классом EventEmitter из NodeJS, чтобы построить событийно-ориентированную систему, которая поможет управлять состоянием приложения.\r\n\r\n![](https://habrastorage.org/files/4dc/a12/94a/4dca1294a4c34adea48bf8da61e7a692.png)\r\n\r\nFacebook предоставляет библиотеку (`npm i flux`), которая содержит реализацию Dispatcher. Dispatcher по своей сути является event-системой. Он траслирует события и регистрирует колбэки. Есть только один глобальный dispatcher. Он очень легко инициализируется:\r\n\r\n**client/dispatcher/AppDispatcher.js**\r\n```\r\nimport { Dispatcher } from 'flux';\r\n\r\nexport default new Dispatcher();\r\n```\r\nВ сущности, Диспетчер — это менеджер всего этого процесса. Это центральный узел вашего приложения. Диспетчер получает на вход действия и рассылает эти действия (и связанные с ними данные) зарегистрированным обработчикам.\r\n\r\nActions — хелперы, упрощающие передачу данных Диспетчеру. Это набор методов, которые вызываются из Представлений (или из любых других мест), чтобы отправить Действия Диспетчеру. В реализации Facebook Действия различаются по типу — константе, которая посылается вместе с данными действия. В зависимости от типа, Действия могут быть соответствующим образом обработаны в зарегистрированных обработчиках, при этом данные из этих Действий используются как аргументы внутренних методов.\r\n\r\nОбъявление констант:\r\n\r\n**client/constants/AppConstants.js**\r\n```\r\nimport keyMirror from 'keymirror';\r\n\r\nexport default keyMirror({\r\n    LOAD_NOTES_REQUEST: null,\r\n    LOAD_NOTES_SUCCESS: null,\r\n    LOAD_NOTES_FAIL: null\r\n});\r\n```\r\n\r\nМы использовали библиотеку keyMirror чтобы создать объект со значениями, идентичными своим ключам.\r\n\r\nДействия же выглядят таким образом:\r\n\r\n**client/actions/NotesActions.js**\r\n```\r\nimport AppDispatcher from '../dispatcher/AppDispatcher';\r\nimport Constants from '../constants/AppConstants';\r\n\r\nimport api from '../api';\r\n\r\nconst NoteActions = {\r\n    loadNotes() {\r\n        AppDispatcher.dispatch({\r\n            type: Constants.LOAD_NOTES_REQUEST\r\n        });\r\n\r\n        api.listNotes()\r\n        .then(({ data }) =>\r\n            AppDispatcher.dispatch({\r\n                type: Constants.LOAD_NOTES_SUCCESS,\r\n                notes: data\r\n            })\r\n        )\r\n        .catch(err =>\r\n            AppDispatcher.dispatch({\r\n                type: Constants.LOAD_NOTES_FAIL,\r\n                error: err\r\n            })\r\n        );\r\n    },\r\n\r\n    createNote(note) {\r\n        api.createNote(note)\r\n        .then(() =>\r\n            this.loadNotes()\r\n        )\r\n        .catch(err =>\r\n            console.error(err)\r\n        );\r\n    },\r\n\r\n    deleteNote(noteId) {\r\n        api.deleteNote(noteId)\r\n        .then(() =>\r\n            this.loadNotes()\r\n        )\r\n        .catch(err =>\r\n            console.error(err)\r\n        );\r\n    }\r\n};\r\n\r\nexport default NoteActions;\r\n```\r\n\r\nХранилища в Flux управляют состоянием определенных частей предметной области вашего приложения. На более высоком уровне это означает, что Хранилища хранят данные, методы получения этих данных и зарегистрированные в Диспетчере обработчики Действий.\r\n\r\n**client/stores/NotesStore.js**\r\n```\r\nimport { EventEmitter } from 'events';\r\n\r\nimport AppDispatcher from '../dispatcher/AppDispatcher';\r\nimport AppConstants from '../constants/AppConstants';\r\n\r\nconst CHANGE_EVENT = 'change';\r\n\r\nlet _notes = [];\r\nlet _loadingError = null;\r\nlet _isLoading = true;\r\n\r\nfunction formatNote(note) {\r\n    return {\r\n        id: note._id,\r\n        title: note.title,\r\n        text: note.text,\r\n        color: note.color || '#ffffff',\r\n        createdAt: note.createdAt\r\n    };\r\n}\r\n\r\nconst NotesStore = Object.assign({}, EventEmitter.prototype, {\r\n    isLoading() {\r\n        return _isLoading;\r\n    },\r\n\r\n    getNotes() {\r\n        return _notes;\r\n    },\r\n\r\n    emitChange: function() {\r\n        this.emit(CHANGE_EVENT);\r\n    },\r\n\r\n    addChangeListener: function(callback) {\r\n        this.on(CHANGE_EVENT, callback);\r\n    },\r\n\r\n    removeChangeListener: function(callback) {\r\n        this.removeListener(CHANGE_EVENT, callback);\r\n    }\r\n});\r\n\r\nAppDispatcher.register(function(action) {\r\n    switch(action.type) {\r\n        case AppConstants.LOAD_NOTES_REQUEST: {\r\n            _isLoading = true;\r\n\r\n            NotesStore.emitChange();\r\n            break;\r\n        }\r\n\r\n        case AppConstants.LOAD_NOTES_SUCCESS: {\r\n            _isLoading = false;\r\n            _notes = action.notes.map( formatNote );\r\n            _loadingError = null;\r\n\r\n            NotesStore.emitChange();\r\n            break;\r\n        }\r\n\r\n        case AppConstants.LOAD_NOTES_FAIL: {\r\n            _loadingError = action.error;\r\n\r\n            NotesStore.emitChange();\r\n            break;\r\n        }\r\n\r\n        default: {\r\n            console.log('No such handler');\r\n        }\r\n    }\r\n});\r\n\r\nexport default NotesStore;\r\n```\r\n\r\nСамое важное, что мы сделали — добавили к нашему хранилищу возможности EventEmitter из NodeJS. Это позволяет хранилищам слушать и рассылать события, что, в свою очередь, позволяет компонентам представления обновляться, отталкиваясь от этих событий. Так как наше представление слушает событие «change», создаваемое Хранилищами, оно узнаёт о том, что состояние приложения изменилось, и пора получить (и отобразить) актуальное состояние.\r\n\r\nТакже мы зарегистрировали обработчик в нашем AppDispatcher с помощью его метода register. Это означает, что теперь наше Хранилище теперь слушает оповещения от AppDispatcher. Исходя из полученных данных, оператор switch решает, можем ли мы обработать Действие. Если действие было обработано, создается событие «change», и Представления, подписавшиеся на это событие, реагируют на него обновлением своего состояния:\r\n\r\n![](https://habrastorage.org/files/e4c/e7a/a88/e4ce7aa881f94a549a3b6c987d4e3e1c.png)\r\n\r\nПредставление использует метод getNotes интерфейса Хранилища для того, чтобы получить все notes из внутреннего объекта _notes и передать эти данные в компоненты. Это очень простой пример, однако такая архитектура позволяет компонентам оставаться достаточно аккуратными, даже если вместо Представлений использовать более сложную логику.\r\n\r\nТогда в компоненте нам нужно подписаться на изменения в хранилище и вызывать действия.\r\n\r\n**client/components/App.jsx**\r\n```\r\nimport React from 'react';\r\n\r\nimport NotesStore from '../stores/NotesStore';\r\nimport NotesActions from '../actions/NotesActions';\r\n\r\nimport NoteEditor from './NoteEditor.jsx';\r\nimport NotesGrid from './NotesGrid.jsx';\r\n\r\nimport './App.less';\r\n\r\nfunction getStateFromFlux() {\r\n    return {\r\n        isLoading: NotesStore.isLoading(),\r\n        notes: NotesStore.getNotes()\r\n    };\r\n}\r\n\r\nconst App = React.createClass({\r\n    getInitialState() {\r\n        return getStateFromFlux();\r\n    },\r\n\r\n    componentWillMount() {\r\n        NotesActions.loadNotes();\r\n    },\r\n\r\n    componentDidMount() {\r\n        NotesStore.addChangeListener(this._onChange);\r\n    },\r\n\r\n    componentWillUnmount() {\r\n        NotesStore.removeChangeListener(this._onChange);\r\n    },\r\n\r\n    handleNoteDelete(note) {\r\n        NotesActions.deleteNote(note.id);\r\n    },\r\n\r\n    handleNoteAdd(noteData) {\r\n        NotesActions.createNote(noteData);\r\n    },\r\n\r\n    render() {\r\n        return (\r\n            <div className='App'>\r\n                <h2 className='App__header'>NotesApp</h2>\r\n                <NoteEditor onNoteAdd={this.handleNoteAdd} />\r\n                <NotesGrid notes={this.state.notes} onNoteDelete={this.handleNoteDelete} />\r\n            </div>\r\n        );\r\n    },\r\n\r\n    _onChange() {\r\n        this.setState(getStateFromFlux());\r\n    }\r\n});\r\n\r\nexport default App;\r\n```\r\n\r\nА уже этот компонент будет передавать данные всем дочерним компонентам через props.\r\n\r\n### Запуск проекта\r\n\r\n1. Clone this repo\r\n2. `cd spa-webinar`\r\n3. `npm install`\r\n4. Скопируйте `etc/config.js.sample` в `etc/config.js`\r\n4. `npm run server`\r\n5. `npm run webpack-devserver`\r\n6. Откройте http://localhost:8090 в браузере\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}