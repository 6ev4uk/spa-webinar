<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>SPA на React, NodeJS, Express и MongoDB by krambertech</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">SPA на React, NodeJS, Express и MongoDB</h1>
      <h2 class="project-tagline">Вебинар проходил 10 марта 2015</h2>
      <a href="https://github.com/krambertech/spa-webinar" class="btn">View on GitHub</a>
      <a href="https://github.com/krambertech/spa-webinar/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/krambertech/spa-webinar/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="Материалы-к-вебинару-Разработка-spa-на-react-nodejs-express-и-mongodb" class="anchor" href="#%D0%9C%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D1%8B-%D0%BA-%D0%B2%D0%B5%D0%B1%D0%B8%D0%BD%D0%B0%D1%80%D1%83-%D0%A0%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-spa-%D0%BD%D0%B0-react-nodejs-express-%D0%B8-mongodb" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Материалы к вебинару "Разработка SPA на React, NodeJS, Express и MongoDB"</h1>

<h3>
<a id="План-вебинара" class="anchor" href="#%D0%9F%D0%BB%D0%B0%D0%BD-%D0%B2%D0%B5%D0%B1%D0%B8%D0%BD%D0%B0%D1%80%D0%B0" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>План вебинара</h3>

<ul>
<li>Краткое введение в NodeJS и npm</li>
<li>Написание простого сервера на NodeJS</li>
<li>Кратко о MongoDB, взаимодействие с базой данных</li>
<li>Написание компонентов на ReactJS</li>
<li>Кратко об архитектуре Flux</li>
<li>Получение и обработка данных с API</li>
<li>Распределение данных внутри приложения</li>
<li>Динамика в приложении</li>
</ul>

<h3>
<a id="Вспомогательные-материлы" class="anchor" href="#%D0%92%D1%81%D0%BF%D0%BE%D0%BC%D0%BE%D0%B3%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BC%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D0%BB%D1%8B" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Вспомогательные материлы</h3>

<p>В рамках данного вебинара мы напишем небольшое приложение для создания и хранения заметок (<a href="cc%D1%8B%D0%BB%D0%BA%D0%B0">такое</a>) на NodeJS, Express, MongoDB и React.</p>

<h4>
<a id="1-Введение-в-nodejs-и-npm" class="anchor" href="#1-%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-nodejs-%D0%B8-npm" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>1. Введение в Node.js и npm</h4>

<p>Node.js - программная платформа, основанная на движке Javascript V8. Она позволяет выполнять Javascript код на сервере.</p>

<p>Первое, что нужно сделать - это установить Node.js. Вместе с ним в комплекте идет также и npm (Node Package Manager) - менеджер пакетов. В зависимости от используемой операционной системы, у Вас естьтакие варианты:</p>

<ul>
<li>Для Windows: <a href="https://nodejs.org/en/download">скачать .msi установщик</a>
</li>
<li>Для Linux: запустить <code>curl -L https://npmjs.org/install.sh | sh</code> в терминале</li>
<li>Для Mac: <a href="https://nodejs.org/en/download">скачать .pkg установщик</a> или <code>brew install node</code>, если используете <a href="http://brew.sh/">Homebrew</a>
</li>
</ul>

<p>После установки, можно проверить наличие Node.js и npm на Вашем компьютере.</p>

<pre><code>node -v
v5.1.0

npm -v
3.3.12
</code></pre>

<h4>
<a id="2-hello-world-на-nodejs" class="anchor" href="#2-hello-world-%D0%BD%D0%B0-nodejs" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>2. Hello world на Node.js</h4>

<p>Давайте приступим к делу и напишем наше первое Node.js приложение «Hello world».</p>

<p>Откройте любой редактор и создайте файл под названием helloworld.js. В нем мы хотим вывести строку «Hello world» в консоль, для этого пишем следующий код:</p>

<pre><code>console.log("Hello World");
</code></pre>

<p>Сохраняем файл и выполняем его посредством Node.js из терминала:</p>

<pre><code>node helloworld.js
</code></pre>

<p>Эта команда должна вывести Hello World в вашем терминале.</p>

<h4>
<a id="3-Постановка-задачи" class="anchor" href="#3-%D0%9F%D0%BE%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3. Постановка задачи</h4>

<p>Мы будем создавать приложения для работы с заметками с таким функционалом:</p>

<pre><code>1. Добавить заметку
2. Просмотреть заметки
3. Удалить заметку
</code></pre>

<p>В самом начале, нам нужно спроектировать API сервера. Исходя из определенного выше функционала и опираясь на методолгию REST, нам понадобятся такие вызовы:</p>

<pre><code>`GET /notes` - получить все заметки
`POST /notes` - создать новую заметку
`DELETE /notes/:id` - удалить заметку
</code></pre>

<h4>
<a id="4-Использование-express" class="anchor" href="#4-%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-express" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4. Использование Express</h4>

<p><a href="http://expressjs.com/">Express</a> - это минималистичный и гибкий веб-фреймворк для приложений Node.js, предоставляющий обширный набор функций. Он значительно упрощает маршрутизацию, использование промежуточных обработчиков (middleware), обработку запросов и отладку.</p>

<p>Создадим новую папку для проекта. Добавим в нее файл <code>package.json</code> приблизительно такого содержания:</p>

<pre><code>{
  "name": "NotesApp",
  "version": "0.0.1",
  "description": "Notes application",
  "scripts": {
    "server": "babel-node server/app.js",
  },
  "author": {
    "name": "Kateryna Porshnieva",
    "email": "k.porshnieva@gmail.com",
    "url": "https://github.com/krambertech"
  },
  "dependencies": {
    "body-parser": "*",
    "cors": "*",
    "express": "*",
    "mongoose": "*"
  },
  "devDependencies": {
    "babel": "5.x",
    "babel-loader": "5.x"
  }
}

</code></pre>

<p>Создадим папку <code>/server</code> - в ней будет храниться весь код, относящийся к серверной части приложения (бекенд). В ней создадим файл <code>app.js</code> - главный файл нашего сервера.</p>

<p><strong>Примечание:</strong> Весь последующий код будет написан в стандарте ES2015 (ES6).</p>

<pre><code>import express from 'express';

const app = express();

const server = app.listen(8080, () =&gt; {
    console.log(`Server is up and running on port 8080`);
});
</code></pre>

<p>Здесь мы создали express-приложение и запустили веб-сервер на порте 8080. Для того, чтобы запустить его нужно выполнить в терминале <code>babel-node server/app.js</code>.</p>

<p>Пока что наш сервер ничего не умеет делать, давайте создадим для него новый маршрут:</p>

<pre><code>import express from 'express';

const app = express();

app.get('/', (req, res) =&gt; {
    res.send('Hello World!');
});

const server = app.listen(8080, () =&gt; {
    console.log(`Server is up and running on port 8080`);
});
</code></pre>

<p>Теперь если открыть http://localhost:8080/ то вы увидите надпись "Hello world". Маршруты в Express описываются очень просто:</p>

<pre><code>app.get('/grapes', (req, res) =&gt; {});
app.post('/grapes', (req, res) =&gt; {});
app.put('/grapes', (req, res) =&gt; {});
app.delete('/grapes', (req, res) =&gt; {});
</code></pre>

<p>Вы пишете <code>app.метод(маршрут, функция)</code>. Маршрут затем будет трансформирован в резулярное выражение, чтобы сервер понимал какие запросы как нужно обработать. Функция принимает объекты req (<a href="http://expressjs.com/ru/4x/api.html#req">объект запроса</a>), res (<a href="http://expressjs.com/ru/4x/api.html#res">объект ответа</a>) и next (функцию для вызова следующего обработчика).</p>

<h4>
<a id="5-mongodb-и-mongoose" class="anchor" href="#5-mongodb-%D0%B8-mongoose" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>5. MongoDB и mongoose</h4>

<p>MongoDB - это документо-ориентированная СУБД. Данные в MongoDB хранятся в документах, которые объединяются в коллекции. Каждый документ представляет собой JSON-подобную структуру (BSON). Проведя аналогию с реляционными СУБД, можно сказать, что коллекциям соответствуют таблицы, а документам — строки в таблицах. В отличие от РСУБД MongoDB не требует какого-либо описания схемы базы данных — она может постепенно меняться по мере развития приложения, что есть удобно.</p>

<p>Cначала нужно установить MongoDB на свой компьютер. Cсылка для скачивания: <a href="https://www.mongodb.org/downloads">https://www.mongodb.org/downloads</a></p>

<p><strong>Инструкция по установке на Windows:</strong> <a href="http://metanit.com/nosql/mongodb/1.2.php">http://metanit.com/nosql/mongodb/1.2.php</a></p>

<p>Mongoose — самый популярный модуль для работы с mongodb на javascript. Он позволяет очень удобно работать с базой данных, в нем все строится на схемах данных. То есть вы создаете модель хранимых данных в базе, а он уже помогает их типизировать, валидировать, строить бизнес логику поверх них, создавать запросы и т.д.</p>

<p>В базе данных мы будем хранить заметки. Так как в mongoose все строится на моделях данных, нам нужно создать модель (схему) для заметок. Делается это очень просто:</p>

<pre><code>import mongoose from "mongoose";

const Schema = mongoose.Schema;

const NoteSchema = new Schema({
    title     : { type: String },
    text      : { type: String, required: true },
    color     : { type: String },
    createdAt : { type: Date }
});

const Note = mongoose.model('Note', NoteSchema);
</code></pre>

<p>Есть огромное множество встроенных типов и приемов для работы с данными - все их вы можете найти в документации - <a href="http://mongoosejs.com/docs/">http://mongoosejs.com/docs/</a></p>

<p>Сейчас мы создали схему для заметки, а потом, на основе этой схемы, модель. Модель - это класс, с помощью которого будут строиться документы в коллекции. В этом случае, каждый документ будет заметкой с параметрами и поведением, которое мы определили. Например, у каждой заметки есть заголовок, текст, цвет и дата создания. Из всех полей, только тект является обязательным - он помечен <code>required</code>.</p>

<p>Также к схемам можно добавлять методы:</p>

<pre><code>var mongoose = require('mongoose');
mongoose.connect('mongodb://localhost/kittens');

var kittySchema = mongoose.Schema({
    name: String
});

kittySchema.methods.speak = function () {
  var greeting = this.name
    ? "Meow name is " + this.name
    : "I don't have a name";
  console.log(greeting);
}

var Kitten = mongoose.model('Kitten', kittySchema);

var fluffy = new Kitten({ name: 'fluffy' });

fluffy.speak();
</code></pre>

<p>Мы с вами создали говорящих котят. Для того, чтобы сохранить Флаффи в базу данных, нам нужно просто написать:</p>

<pre><code>fluffy.save(function (err, fluffy) {
  if (err) return console.error(err);
  fluffy.speak();
});
</code></pre>

<p>Теперь для того, чтобы получить всех котят, мы можем использовать метод find:</p>

<pre><code>Kitten.find(function (err, kittens) {
  if (err) return console.error(err);
  console.log(kittens);
})
</code></pre>

<p>Чтобы найти всех котят по имени fluffy:</p>

<pre><code>Kitten.find({ name: "fluffy" }, callback);
</code></pre>

<p>Теперь давайте отойдем от котят и вернемся к нашим заметкам. Сохраним модель заметки в папке <code>/server/models/Note.js</code>. Теперь нужно связать взаимодействие с базой данных и запросы. Для работы с базой мы создадим утилиту <code>server/utils/DataBaseUtils.js</code>, в которой просто изолируем методы для работы с базой.</p>

<p>Сначала нам нужно настроить соединение:</p>

<pre><code>import mongoose from "mongoose";

import '../models/Note';

const Note = mongoose.model('Note');

export function setUpConnection() {
    mongoose.connect(`mongodb://localhost/notes`);
}
</code></pre>

<p>И добавим несколько методов для взаимодействия с базой:</p>

<pre><code>export function listNotes(id) {
    return Note.find();
}

export function createNote(data) {
    const note = new Note({
        title: data.title,
        text: data.text,
        color: data.color,
        createdAt: new Date()
    });

    return note.save();
}

export function deleteNote(id) {
    return Note.findById(id).remove();
}
</code></pre>

<p>Теперь нужно создать соответствующие маршруты. Вернемся к файлу <code>/server/app.js</code>.</p>

<p>Данные мы будем получать в формате json, для того, чтобы удобно с ними взаимодействовать мы будем использовать промежуточный обработчик <a href="https://github.com/expressjs/body-parser">body-parser</a>. Он будет вызван всякий раз, когда прийдет запрос - он сначала преобразует данные, а затем передаст управление нашим обработчикам.</p>

<p>Используется он таким образом:</p>

<pre><code>import bodyParser from 'body-parser';

// ...

app.use( bodyParser.json() );
</code></pre>

<p>Теперь данные, полученые в json формате будут обработаны корректно.</p>

<p>В итоге, наш файл <code>app.js</code> выглядит вот так:</p>

<pre><code>import express from 'express';
import bodyParser from 'body-parser';

import * as db from './utils/DataBaseUtils';

// Initialization of express application
const app = express();

// Set up connection of database
db.setUpConnection();

// Using bodyParser middleware
app.use( bodyParser.json() );

// RESTful api handlers
app.get('/notes', (req, res) =&gt; {
    db.listNotes().then(data =&gt; res.send(data));
});

app.post('/notes', (req, res) =&gt; {
    db.createNote(req.body).then(data =&gt; res.send(data));
});

app.delete('/notes/:id', (req, res) =&gt; {
    db.deleteNote(req.params.id).then(data =&gt; res.send(data));
});

const server = app.listen(8080, function() {
    console.log(`Server is up and running on port 8080`);
</code></pre>

<p>После обращения к базе мы используем промисы (Promise), они предоставляют удобный способ организации асинхронного кода.</p>

<p>На этом почти все, мы создали серверное приложение на node.js. Еще было бы неплохо создать для него конфигурацию, то есть вынести некоторые переменные в конфиг. Создадим файл <code>/etc/config.json</code>:</p>

<pre><code>{
    "apiPrefix": "http://localhost:8080",
    "serverPort": "8080",
    "db":{
        "name": "notes",
        "host": "localhost",
        "port": 27017
    }
}
</code></pre>

<p>Теперь при использовании этих переменных, будем обращаться к этому файлу.</p>

<p><strong>app.js</strong></p>

<pre><code>import express from 'express';
import cors from 'cors';
import bodyParser from 'body-parser';

import { serverPort } from '../etc/config.json';

import * as db from './utils/DataBaseUtils';

// Initialization of express application
const app = express();

// Set up connection of database
db.setUpConnection();

// Using bodyParser middleware
app.use( bodyParser.json() );

// Allow requests from any origin
app.use(cors({ origin: '*' }));

// RESTful api handlers
app.get('/notes', (req, res) =&gt; {
    db.listNotes().then(data =&gt; res.send(data));
});

app.post('/notes', (req, res) =&gt; {
    db.createNote(req.body).then(data =&gt; res.send(data));
});

app.delete('/notes/:id', (req, res) =&gt; {
    db.deleteNote(req.params.id).then(data =&gt; res.send(data));
});

const server = app.listen(serverPort, function() {
    console.log(`Server is up and running on port ${serverPort}`);
});
</code></pre>

<p><strong>DataBaseUtils.js</strong></p>

<pre><code>import mongoose from "mongoose";

import config from '../../etc/config.json';

import '../models/Note';

const Note = mongoose.model('Note');

export function setUpConnection() {
    mongoose.connect(`mongodb://${config.db.host}:${config.db.port}/${config.db.name}`);
}

export function listNotes(id) {
    return Note.find();
}

export function createNote(data) {
    const note = new Note({
        title: data.title,
        text: data.text,
        color: data.color,
        createdAt: new Date()
    });

    return note.save();
}

export function deleteNote(id) {
    return Note.findById(id).remove();
}
</code></pre>

<h4>
<a id="6-Введение-в-react" class="anchor" href="#6-%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-react" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>6. Введение в React</h4>

<p>ReactJS - это JаvaScript библиотека для построения пользовательских интерфейсов. Это не MVC фреймворк. К нему можно применить только V из этой аббревиатуры. Такая узкая сфера применения дает свободу использования React в различных системах в комбинации с другими библиотеками.</p>

<p>React был представлен Facebook в 2013 году, и очень быстро обрел популярность. Сегодня его используют многие известные компании включая Instagram, Airbnb, Ebay, Netflix, Yahoo и другие.</p>

<p>Основным отличием React от других JavaScript фреймворков является то, как он управляет состоянием приложения. Если вспомнить, как пользователи взаимодействовали с веб-страницами еще 10-15 лет назад, то увидим такую картину:</p>

<p><img src="https://github.com/krambertech/react-essential-course/raw/master/01-introduction-to-react/images/001.png" alt=""></p>

<p>Сервер всегда возвращал статическую страницу, и реакцией на действия пользователя была полная перезагрузка страницы. Преимуществами такого подхода, была простота в реализации и понимании, недостатками - скорость работы, отзывчивость, UX и потеря состояния при каждой перезагрузке.</p>

<p>Все очень изменилось с появлением AJAX, это подход к построению интерактивных веб-приложений, заключающийся в «фоновом» обмене данными браузера с веб-сервером. То есть, в фоновом режиме отправляются запросы на сервер, приходят с него ответы, изменяется состояние приложения и, соответственно, внешний вид. Именно такой подход породил понятие Single Page Application.</p>

<p><img src="https://github.com/krambertech/react-essential-course/raw/master/01-introduction-to-react/images/002.png" alt=""></p>

<p>Но каждое визуальное изменение на странице соответствует изменению ее DOM дерева. Не секрет, что все манипуляции с DOM деревом являются очень ресурсоемкими операциями, т.к. изначально DOM дерево было статическим и никакой динамики не предусматривало.</p>

<p><img src="https://github.com/krambertech/react-essential-course/raw/master/01-introduction-to-react/images/006.png" alt=""></p>

<p>Именно поэтому в React используется виртуальный DOM. Это такая легковесная копия реального DOM дерева на Javascript. Таким образом, React манипулирует не с реальным (синоним - медленным) DOM деревом, а с виртуальным.</p>

<p><img src="https://github.com/krambertech/react-essential-course/raw/master/01-introduction-to-react/images/003.png" alt=""></p>

<p>Он сравнивает предыдущее состояние виртуального DOM дерева с его следующим состоянием и находит минимальное количество манипуляций, которые можно произвести уже с реальным DOM, чтобы обновить вид приложения согласно его новому состоянию.</p>

<p><img src="https://github.com/krambertech/react-essential-course/raw/master/01-introduction-to-react/images/004.png" alt=""></p>

<p>И это действительно быстро работает. А все что вам нужно делать - это просто менять состояние вашего приложения, а все остальное React сделает уже за вас!</p>

<p>Все приложение на React строится из небольших кирпичиков - компонентов. Такое построение приложения упрощает поддержку и работу над кодом в команде. В идеале, все компоненты должны быть независимыми и каждый должен делать свою задачу и делать ее хорошо.</p>

<h4>
<a id="jsx" class="anchor" href="#jsx" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>JSX</h4>

<p>Для рендеринга данных в React используется JSX. JSX нужен для JavaScript XML — разметки в стиле XML внутри компонентов React. React работает и без JSX, но именно JSX поможет сделать ваши компоненты более читаемыми, поэтому рекомендуется использовать его.</p>

<div class="highlight highlight-source-js-jsx"><pre><span class="pl-c">// с JSX</span>
<span class="pl-k">var</span><span class="pl-smi"> app</span><span class="pl-k"> =</span> &lt;<span class="pl-ent">Nav</span> <span class="pl-e">color</span>=“blue<span class="pl-s"><span class="pl-pds">"</span>&gt;</span>
<span class="pl-s">    &lt;Profile&gt;click&lt;/Profile&gt;</span>
<span class="pl-s">&lt;/Nav&gt;;</span></pre></div>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// без JSX</span>
<span class="pl-k">var</span> app <span class="pl-k">=</span> <span class="pl-smi">React</span>.<span class="pl-c1">createElement</span>(
    Nav,
    {color<span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>blue<span class="pl-pds">"</span></span>},
    <span class="pl-smi">React</span>.<span class="pl-c1">createElement</span>(
        Profile,
        <span class="pl-c1">null</span>,
        <span class="pl-s"><span class="pl-pds">"</span>click<span class="pl-pds">"</span></span>
    )
);</pre></div>

<p>JSX позволяет вам описывать структуру компонентов с помощью понятного синтаксиса, а затем все написанное вами преобразуется в цепочку javascript функций.</p>

<p>В JSX можно использовать переменные, условные конструкции и вызывать функции. Для этого нужно использовать фугурные скобки.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> myName <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>Katya<span class="pl-pds">'</span></span>;
<span class="pl-k">var</span> app <span class="pl-k">=</span> <span class="pl-k">&lt;</span>h1<span class="pl-k">&gt;</span> My name is {myName}<span class="pl-k">!</span> <span class="pl-k">&lt;</span><span class="pl-k">/</span>h1<span class="pl-k">&gt;</span>;</pre></div>

<div class="highlight highlight-source-js-jsx"><pre><span class="pl-k">function</span> <span class="pl-en">getMyName</span>() {
<span class="pl-k">    return</span> <span class="pl-s"><span class="pl-pds">'</span>Katya<span class="pl-pds">'</span></span>;
}

<span class="pl-k">var</span><span class="pl-smi"> app</span><span class="pl-k"> =</span> &lt;<span class="pl-ent">h1</span>&gt;
    My name is <span class="pl-pse">{</span><span class="pl-s1"><span class="pl-en">getMyName</span>()</span><span class="pl-pse">}</span>!
&lt;/<span class="pl-ent">h1</span>&gt;;</pre></div>

<div class="highlight highlight-source-js-jsx"><pre><span class="pl-k">var</span><span class="pl-smi"> age</span><span class="pl-k"> =</span> <span class="pl-c1">20</span>;

<span class="pl-k">var</span><span class="pl-smi"> app</span><span class="pl-k"> =</span> &lt;<span class="pl-ent">h1</span>&gt;
    Hi! <span class="pl-pse">{</span><span class="pl-s1"><span class="pl-smi"> age</span><span class="pl-k"> &gt;</span> <span class="pl-c1">18</span> <span class="pl-k">?</span> <span class="pl-s"><span class="pl-pds">'</span>Your age is more than 18!<span class="pl-pds">'</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Your age is less than 18!<span class="pl-pds">'</span></span> </span><span class="pl-pse">}</span>
&lt;/<span class="pl-ent">h1</span>&gt;;</pre></div>

<h4>
<a id="Компоненты" class="anchor" href="#%D0%9A%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Компоненты</h4>

<p>React использует компонентную модель, то есть все большое приложение делится на небольшие независимые компоненты, которыми гораздо легче управлять.</p>

<div class="highlight highlight-source-js-jsx"><pre><span class="pl-c">// простой компонент</span>
<span class="pl-k">var</span><span class="pl-smi"> HelloWorld</span><span class="pl-k"> =</span> <span class="pl-smi">React</span><span class="pl-k">.</span><span class="pl-en">createClass</span>({
    <span class="pl-en">render</span>: <span class="pl-k">function</span>() {
<span class="pl-k">        return</span> (
            &lt;<span class="pl-ent">h1</span>&gt; Hello world! &lt;/<span class="pl-ent">h1</span>&gt;
        );
    }
});</pre></div>

<p>У каждого компонента есть один обязательный метод - <code>render</code>, который возвращает JSX разметку, соответствующую виду компонента.</p>

<h4>
<a id="Параметры-aka-props" class="anchor" href="#%D0%9F%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D1%8B-aka-props" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Параметры aka props</h4>

<p>Каждый компонент может принимать параметры. Они передаются из выше стоящих компонентов.  К параметрам компонента можно обращаться используя <code>this.props.propName</code>.</p>

<div class="highlight highlight-source-js-jsx"><pre><span class="pl-k">var</span><span class="pl-smi"> Heading</span><span class="pl-k"> =</span> <span class="pl-smi">React</span><span class="pl-k">.</span><span class="pl-en">createClass</span>({
    <span class="pl-en">render</span>: <span class="pl-k">function</span>() {
<span class="pl-k">        return</span> &lt;<span class="pl-ent">h1</span>&gt; My name is <span class="pl-pse">{</span><span class="pl-s1"><span class="pl-v">this</span><span class="pl-k">.</span><span class="pl-smi">props</span><span class="pl-k">.</span><span class="pl-smi">name</span></span><span class="pl-pse">}</span>!&lt;/<span class="pl-ent">h1</span>&gt;;
    }
});

<span class="pl-k">var</span><span class="pl-smi"> Hello</span><span class="pl-k"> =</span> <span class="pl-smi">React</span><span class="pl-k">.</span><span class="pl-en">createClass</span>({
    <span class="pl-en">render</span>: <span class="pl-k">function</span>() {
<span class="pl-k">        return</span> &lt;<span class="pl-ent">Heading</span> <span class="pl-e">name</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>Katya<span class="pl-pds">"</span></span> /&gt;;
    }
});</pre></div>

<p>Запомните: Модифицировать <code>this.props</code> <strong>крайне нежелательно</strong>*!</p>

<h4>
<a id="Состояние-aka-state" class="anchor" href="#%D0%A1%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5-aka-state" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Состояние aka state</h4>

<p>Также каждый компонент может хранить свое состояние. К нему можно получить доступ, обратившись к <code>this.state</code>. В состоянии компонента стоит хранить данные, от которых компонент напрямую зависит внешний вид компонента, и при изменении которых его внешний вид тоже должен меняться (будет вызываться метод <code>render</code>). Cостояние компонента доступно только внутри самого компонента. Для объявления начального состояния компонента, нужно использовать метод <code>getInitialState</code>. Этот метод вызывается до того, как компонент отобразиться в доме и определяет первоначальное значение состояния компонента. Для того, чтобы модифицировать состояние компонента нужно вызвать метод <code>this.setState({ /* новое состояние */ })</code>, тогда состояние компонента измениться и вызовется метод <code>render</code>.</p>

<div class="highlight highlight-source-js-jsx"><pre><span class="pl-k">var</span><span class="pl-smi"> Component</span><span class="pl-k"> =</span> <span class="pl-smi">React</span><span class="pl-k">.</span><span class="pl-en">createClass</span>({
  <span class="pl-en">getInitialState</span> : <span class="pl-k">function</span>() {
<span class="pl-k">    return</span> {
<span class="pl-c1">      <span class="pl-s">name</span> :</span> <span class="pl-s"><span class="pl-pds">"</span>Katya<span class="pl-pds">"</span></span>
    };
  },

  <span class="pl-en">handleClick</span> : <span class="pl-k">function</span>() {
<span class="pl-v">    this</span><span class="pl-k">.</span><span class="pl-en">setState</span>({
<span class="pl-c1">      <span class="pl-s">name</span> :</span> <span class="pl-s"><span class="pl-pds">"</span>Vasya<span class="pl-pds">"</span></span>
    });
  },

  <span class="pl-en">render</span> : <span class="pl-k">function</span>() {
<span class="pl-k">    return</span> &lt;<span class="pl-ent">div</span> <span class="pl-e">onClick</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-s1"><span class="pl-v">this</span><span class="pl-k">.</span><span class="pl-smi">handleClick</span></span><span class="pl-pse">}</span>&gt;
      Hello, <span class="pl-pse">{</span><span class="pl-s1"><span class="pl-v">this</span><span class="pl-k">.</span><span class="pl-smi">state</span><span class="pl-k">.</span><span class="pl-smi">name</span></span><span class="pl-pse">}</span>
    &lt;/<span class="pl-ent">div</span>&gt;;
  }
});
</pre></div>

<p><strong>Состояние нужно использовать только там, где это действительно необходимо!</strong></p>

<p><strong>НИКОГДА</strong> не нужно модифицировать <code>this.state</code> напрямую!</p>

<h4>
<a id="Обработка-событий" class="anchor" href="#%D0%9E%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Обработка событий</h4>

<p>Если вы захотите сделать свои компоненты динамическими, то вам не обойтись без использования событий. Обычно, для каждого события описывается обработчик, в котором вы можете произвести какие-то действия.</p>

<div class="highlight highlight-source-js-jsx"><pre><span class="pl-k">var</span><span class="pl-smi"> HelloComponent</span><span class="pl-k"> =</span> <span class="pl-smi">React</span><span class="pl-k">.</span><span class="pl-en">createClass</span>({
  <span class="pl-en">handleClick</span> : <span class="pl-k">function</span>() {
    <span class="pl-en">alert</span>(<span class="pl-s"><span class="pl-pds">'</span>Hello stranger!<span class="pl-pds">'</span></span>);
  },

  <span class="pl-en">render</span> : <span class="pl-k">function</span>() {
<span class="pl-k">    return</span> &lt;<span class="pl-ent">button</span> <span class="pl-e">onClick</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-s1"><span class="pl-v">this</span><span class="pl-k">.</span><span class="pl-smi">handleClick</span></span><span class="pl-pse">}</span>&gt; Say hello &lt;/<span class="pl-ent">button</span>&gt;;
  }
});</pre></div>

<p>Во все такие обработчики событий в качестве аргумента приходит объект <code>SyntheticEvent</code>. Это объект, который является кроссбраузерной оберткой над стандартными событиями.</p>

<div class="highlight highlight-source-js-jsx"><pre><span class="pl-k">var</span><span class="pl-smi"> EventComponent</span><span class="pl-k"> =</span> <span class="pl-smi">React</span><span class="pl-k">.</span><span class="pl-en">createClass</span>({
  <span class="pl-en">handleClick</span> : <span class="pl-k">function</span>(<span class="pl-smi">event</span>) {
    <span class="pl-en">alert</span>(<span class="pl-s"><span class="pl-pds">'</span>Event handled - <span class="pl-pds">'</span></span><span class="pl-k"> +</span><span class="pl-smi"> event</span><span class="pl-k">.</span><span class="pl-smi">type</span>);<span class="pl-c"> // Event handled - click</span>
  },

  <span class="pl-en">render</span> : <span class="pl-k">function</span>() {
<span class="pl-k">    return</span> &lt;<span class="pl-ent">button</span> <span class="pl-e">onClick</span><span class="pl-k">=</span><span class="pl-pse">{</span><span class="pl-s1"><span class="pl-v">this</span><span class="pl-k">.</span><span class="pl-smi">handleClick</span></span><span class="pl-pse">}</span>&gt; Click me &lt;/<span class="pl-ent">button</span>&gt;;
  }
});</pre></div>

<p>О том, какие события поддерживаются можно прочитать <a href="https://facebook.github.io/react/docs/events.html">тут</a>.</p>

<h4>
<a id="reactjs-hello-world" class="anchor" href="#reactjs-hello-world" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ReactJS Hello world</h4>

<p>Начнем с простого подключения React в html документе</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Hello World!&lt;/title&gt;
    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.0/react.js"&gt;&lt;/script&gt;
    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.0/react-dom.js"&gt;&lt;/script&gt;
    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.6.15/browser.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id='content'&gt;&lt;/div&gt;

    &lt;script type="text/babel"&gt;
        const HelloWorld = React.createClass({
            render() {
                return (
                    &lt;h1&gt; Hello world! &lt;/h1&gt;
                );
            }
        });

        ReactDOM.render(
            &lt;HelloWorld /&gt;,
            document.getElementById('content')
        );
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>В параметрах мы можем передавать значения компоненту, которые он будет уже использовать внутри себя, обращаясь к <code>this.props</code>.</p>

<pre><code>const HelloWorld = React.createClass({
    render() {
        return (
            &lt;h1&gt; Hello, {this.props.name}! &lt;/h1&gt;
        );
    }
});

ReactDOM.render(
    &lt;HelloWorld name='Vasya' /&gt;,
    document.getElementById('content')
);
</code></pre>

<p>Также мы можем добавить динамику в компонент с помощью использования состояния и обработки событий.</p>

<pre><code>const HelloWorld = React.createClass({
    getInitialState() {
        return {
            name: 'Vasya'
        };
    },

    handleNameChange(e) {
        this.setState({
            name: e.target.value
        });
    },

    render() {
        return (
            &lt;div&gt;
                &lt;h1&gt; Hello {this.state.name}! &lt;/h1&gt;
                &lt;input type='text' value={this.state.name} onChange={this.handleNameChange} /&gt;
            &lt;/div&gt;
        );
    }
});

ReactDOM.render(
    &lt;HelloWorld /&gt;,
    document.getElementById('content')
);
</code></pre>

<h4>
<a id="Сборка-приложения" class="anchor" href="#%D0%A1%D0%B1%D0%BE%D1%80%D0%BA%D0%B0-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Сборка приложения</h4>

<p>Для более сложных проектов уже не выйдет все компоненты описать в index.html. Обычно создается отдельный файл для компонента, то компонент <code>Button</code> будет находиться в файле <code>Button.jsx</code>, а если у него еще есть отдельный файл со стилями, то мы создадим файл <code>Button.css</code> и расположим рядом с файлом компонента и подключим в нем. Основная идея такого подхода стоит в том, чтобы максимально изолировать компонент и все относящиеся к нему зависимости.</p>

<p>Тогда создадим в нащем проекте папку <code>/client</code>, в которой будет располагаться весь код, относящийся к клиентской части приложения. Также мы должны создать главный файл проекта, так называемую "точку входа". Из которого мы будем уже подключать другие модули, а они следующие и так далее. Создадим файл <code>main.js</code>.</p>

<pre><code>import React from 'react';
import ReactDOM from 'react-dom';

ReactDOM.render(
    &lt;h1&gt;Notes&lt;/h1&gt;,
    document.getElementById('mount-point')
);
</code></pre>

<p>Для того, чтобы кучу совершенно разных кусочков проекта (стили, js, json, jsx и т.д.) собрать воедино существуют системы сборки. Их сейчас есть достаточно много: gulp, grunt, broccoli, browserify и т.п. Но мы будем говорить о webpack. Почему именно он? Все очень просто - это самое универсальное и комплексное решение.</p>

<p><img src="https://webpack.github.io/assets/what-is-webpack.png" alt=""></p>

<p>Установим webpack глобально:</p>

<pre><code>npm install webpack -g
</code></pre>

<p>При этом, в нем весь процесс сборки проекты описывается достаточно просто. Вот, например, как будет выглядеть наш конфиг:</p>

<pre><code>var webpack = require('webpack');

module.exports = {
    entry: "./client/main.js",
    output: {
        path: __dirname + '/public/build/',
        publicPath: "build/",
        filename: "bundle.js"
    },
    module: {
        loaders: [
            {
                test: /\.js$/,
                loader: "babel",
                exclude: [/node_modules/, /public/]
            },
            {
                test: /\.less$/,
                loader: "style-loader!css-loader!autoprefixer-loader!less",
                exclude: [/node_modules/, /public/]
            },
            {
                test: /\.jsx$/,
                loader: "react-hot!babel",
                exclude: [/node_modules/, /public/]
            },
            {
                test: /\.json$/,
                loader: "json-loader"
            }
        ]
    }
}
</code></pre>

<p>Мы описывает то, что должно быть на входе и то, что мы хотим получить на выходе. Для осуществления преобразований файлов используются загрузчики.</p>

<p>Чтобы запустить сборку, нужно в терминале выполнить команду</p>

<pre><code>webpack -p
</code></pre>

<p>Тогда появится файл <code>bundle.js</code> cо всем уже минифицированным кодом.</p>

<p>Также для webpack есть утилита <code>webpack-dev-server</code> для запуска development-сервера и отслеживания изменений в файлах. В него можно подключить как hot-reload - автоматическую перезагрузку страницы браузера при изменении файлов проекта, так и hot-module-replacement - возможность при изменении исходников очень быстро отобразить изменения в браузере без перезагрузки страницы, выглядит как магия.</p>

<p>Для запуска <code>webpack-dev-server</code> нам нужно выполнить такую команду:</p>

<pre><code>webpack-dev-server --debug --hot --devtool eval-source-map --output-pathinfo --watch --colors --inline --content-base public --port 8090 --host 0.0.0.0
</code></pre>

<p>Но чтобы такое безобразие каждый раз неписать в консоли, давайте добавим ее в <code>scripts</code> в <code>package.json</code>.</p>

<pre><code>  "scripts": {
    "webpack-devserver": "webpack-dev-server --debug --hot --devtool eval-source-map --output-pathinfo --watch --colors --inline --content-base public --port 8090 --host 0.0.0.0"
  }
</code></pre>

<p>Теперь мы можем просто писать <code>npm run webpack-devserver</code> и данная команда будет выполнена.</p>

<h4>
<a id="flux" class="anchor" href="#flux" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Flux</h4>

<p>Flux — это архитектура, которую команда Facebook использует при работе с React. Это не фреймворк, или библиотека, это новый архитектурный подход, который дополняет React и принцип однонаправленного потока данных.</p>

<p>Типичная реализация архитектуры Flux может использовать эту библиотеку вместе с классом EventEmitter из NodeJS, чтобы построить событийно-ориентированную систему, которая поможет управлять состоянием приложения.</p>

<p><img src="https://habrastorage.org/files/4dc/a12/94a/4dca1294a4c34adea48bf8da61e7a692.png" alt=""></p>

<p>Facebook предоставляет библиотеку (<code>npm i flux</code>), которая содержит реализацию Dispatcher. Dispatcher по своей сути является event-системой. Он траслирует события и регистрирует колбэки. Есть только один глобальный dispatcher. Он очень легко инициализируется:</p>

<p><strong>client/dispatcher/AppDispatcher.js</strong></p>

<pre><code>import { Dispatcher } from 'flux';

export default new Dispatcher();
</code></pre>

<p>В сущности, Диспетчер — это менеджер всего этого процесса. Это центральный узел вашего приложения. Диспетчер получает на вход действия и рассылает эти действия (и связанные с ними данные) зарегистрированным обработчикам.</p>

<p>Actions — хелперы, упрощающие передачу данных Диспетчеру. Это набор методов, которые вызываются из Представлений (или из любых других мест), чтобы отправить Действия Диспетчеру. В реализации Facebook Действия различаются по типу — константе, которая посылается вместе с данными действия. В зависимости от типа, Действия могут быть соответствующим образом обработаны в зарегистрированных обработчиках, при этом данные из этих Действий используются как аргументы внутренних методов.</p>

<p>Объявление констант:</p>

<p><strong>client/constants/AppConstants.js</strong></p>

<pre><code>import keyMirror from 'keymirror';

export default keyMirror({
    LOAD_NOTES_REQUEST: null,
    LOAD_NOTES_SUCCESS: null,
    LOAD_NOTES_FAIL: null
});
</code></pre>

<p>Мы использовали библиотеку keyMirror чтобы создать объект со значениями, идентичными своим ключам.</p>

<p>Действия же выглядят таким образом:</p>

<p><strong>client/actions/NotesActions.js</strong></p>

<pre><code>import AppDispatcher from '../dispatcher/AppDispatcher';
import Constants from '../constants/AppConstants';

import api from '../api';

const NoteActions = {
    loadNotes() {
        AppDispatcher.dispatch({
            type: Constants.LOAD_NOTES_REQUEST
        });

        api.listNotes()
        .then(({ data }) =&gt;
            AppDispatcher.dispatch({
                type: Constants.LOAD_NOTES_SUCCESS,
                notes: data
            })
        )
        .catch(err =&gt;
            AppDispatcher.dispatch({
                type: Constants.LOAD_NOTES_FAIL,
                error: err
            })
        );
    },

    createNote(note) {
        api.createNote(note)
        .then(() =&gt;
            this.loadNotes()
        )
        .catch(err =&gt;
            console.error(err)
        );
    },

    deleteNote(noteId) {
        api.deleteNote(noteId)
        .then(() =&gt;
            this.loadNotes()
        )
        .catch(err =&gt;
            console.error(err)
        );
    }
};

export default NoteActions;
</code></pre>

<p>Хранилища в Flux управляют состоянием определенных частей предметной области вашего приложения. На более высоком уровне это означает, что Хранилища хранят данные, методы получения этих данных и зарегистрированные в Диспетчере обработчики Действий.</p>

<p><strong>client/stores/NotesStore.js</strong></p>

<pre><code>import { EventEmitter } from 'events';

import AppDispatcher from '../dispatcher/AppDispatcher';
import AppConstants from '../constants/AppConstants';

const CHANGE_EVENT = 'change';

let _notes = [];
let _loadingError = null;
let _isLoading = true;

function formatNote(note) {
    return {
        id: note._id,
        title: note.title,
        text: note.text,
        color: note.color || '#ffffff',
        createdAt: note.createdAt
    };
}

const NotesStore = Object.assign({}, EventEmitter.prototype, {
    isLoading() {
        return _isLoading;
    },

    getNotes() {
        return _notes;
    },

    emitChange: function() {
        this.emit(CHANGE_EVENT);
    },

    addChangeListener: function(callback) {
        this.on(CHANGE_EVENT, callback);
    },

    removeChangeListener: function(callback) {
        this.removeListener(CHANGE_EVENT, callback);
    }
});

AppDispatcher.register(function(action) {
    switch(action.type) {
        case AppConstants.LOAD_NOTES_REQUEST: {
            _isLoading = true;

            NotesStore.emitChange();
            break;
        }

        case AppConstants.LOAD_NOTES_SUCCESS: {
            _isLoading = false;
            _notes = action.notes.map( formatNote );
            _loadingError = null;

            NotesStore.emitChange();
            break;
        }

        case AppConstants.LOAD_NOTES_FAIL: {
            _loadingError = action.error;

            NotesStore.emitChange();
            break;
        }

        default: {
            console.log('No such handler');
        }
    }
});

export default NotesStore;
</code></pre>

<p>Самое важное, что мы сделали — добавили к нашему хранилищу возможности EventEmitter из NodeJS. Это позволяет хранилищам слушать и рассылать события, что, в свою очередь, позволяет компонентам представления обновляться, отталкиваясь от этих событий. Так как наше представление слушает событие «change», создаваемое Хранилищами, оно узнаёт о том, что состояние приложения изменилось, и пора получить (и отобразить) актуальное состояние.</p>

<p>Также мы зарегистрировали обработчик в нашем AppDispatcher с помощью его метода register. Это означает, что теперь наше Хранилище теперь слушает оповещения от AppDispatcher. Исходя из полученных данных, оператор switch решает, можем ли мы обработать Действие. Если действие было обработано, создается событие «change», и Представления, подписавшиеся на это событие, реагируют на него обновлением своего состояния:</p>

<p><img src="https://habrastorage.org/files/e4c/e7a/a88/e4ce7aa881f94a549a3b6c987d4e3e1c.png" alt=""></p>

<p>Представление использует метод getNotes интерфейса Хранилища для того, чтобы получить все notes из внутреннего объекта _notes и передать эти данные в компоненты. Это очень простой пример, однако такая архитектура позволяет компонентам оставаться достаточно аккуратными, даже если вместо Представлений использовать более сложную логику.</p>

<p>Тогда в компоненте нам нужно подписаться на изменения в хранилище и вызывать действия.</p>

<p><strong>client/components/App.jsx</strong></p>

<pre><code>import React from 'react';

import NotesStore from '../stores/NotesStore';
import NotesActions from '../actions/NotesActions';

import NoteEditor from './NoteEditor.jsx';
import NotesGrid from './NotesGrid.jsx';

import './App.less';

function getStateFromFlux() {
    return {
        isLoading: NotesStore.isLoading(),
        notes: NotesStore.getNotes()
    };
}

const App = React.createClass({
    getInitialState() {
        return getStateFromFlux();
    },

    componentWillMount() {
        NotesActions.loadNotes();
    },

    componentDidMount() {
        NotesStore.addChangeListener(this._onChange);
    },

    componentWillUnmount() {
        NotesStore.removeChangeListener(this._onChange);
    },

    handleNoteDelete(note) {
        NotesActions.deleteNote(note.id);
    },

    handleNoteAdd(noteData) {
        NotesActions.createNote(noteData);
    },

    render() {
        return (
            &lt;div className='App'&gt;
                &lt;h2 className='App__header'&gt;NotesApp&lt;/h2&gt;
                &lt;NoteEditor onNoteAdd={this.handleNoteAdd} /&gt;
                &lt;NotesGrid notes={this.state.notes} onNoteDelete={this.handleNoteDelete} /&gt;
            &lt;/div&gt;
        );
    },

    _onChange() {
        this.setState(getStateFromFlux());
    }
});

export default App;
</code></pre>

<p>А уже этот компонент будет передавать данные всем дочерним компонентам через props.</p>

<h3>
<a id="Запуск-проекта" class="anchor" href="#%D0%97%D0%B0%D0%BF%D1%83%D1%81%D0%BA-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B0" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Запуск проекта</h3>

<ol>
<li>Clone this repo</li>
<li><code>cd spa-webinar</code></li>
<li><code>npm install</code></li>
<li>Скопируйте <code>etc/config.js.sample</code> в <code>etc/config.js</code>
</li>
<li><code>npm run server</code></li>
<li><code>npm run webpack-devserver</code></li>
<li>Откройте http://localhost:8090 в браузере</li>
</ol>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/krambertech/spa-webinar">SPA на React, NodeJS, Express и MongoDB</a> is maintained by <a href="https://github.com/krambertech">krambertech</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
